{
  "hash": "69e66fb830978e74f3baec62ac3a5f79",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home_Ex01\"\nauthor: \"Hei Yee Kai\"\ndate: \"September 22, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: false\n  echo: true\n  freeze: true\n---\n\n\n## **Introduction**\n\nArmed conflicts continue to wreak havoc worldwide, disrupting the lives of millions annually. After a relative decline in the 1990s and early 2000s, conflicts have surged since 2012, triggered by events such as the 2011 Arab uprisings that sparked wars in Libya, Syria, and Yemen. The instability in Libya further contributed to prolonged unrest in the Sahel region. This period of escalating violence has been marked by numerous high-profile conflicts: the 2020 war between Azerbaijan and Armenia over Nagorno-Karabakh, the brutal fighting in Ethiopia’s Tigray region, Myanmar's descent into conflict following a military coup in 2021, and Russia’s invasion of Ukraine in 2022. In 2023, violence intensified in Sudan and Gaza, adding to the mounting toll of human suffering. Today, more people are experiencing death, displacement, and a critical need for humanitarian aid than at any time in recent decades.\n\n## **Importing Packages**\n\nBefore we start the exercise, we will need to import necessary R packages first. We will use the following packages:\n\n-   [`sf`](https://rdrr.io/github/r-spatial/sf/man/sf-package.html) : provides a standardised way to encode spatial vector data in R environment, facilitating spatial data operations and analysis.\n\n-   [`st`](https://rdrr.io/cran/sf/man/st.html) : creats simple features from numeric vectors, matrices, or lists, enabling the representation and manipulation of spatial structures in R.\n\n-   [`spatstat`](https://cran.r-project.org/web/packages/spatstat/): A package for statistical analysis of spatial data, specifically Spatial Point Pattern Analysis. This package was provided by Baddeley, Turner and Ruback (2015) and gives a comprehensive list of functions to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.\n\n-   [`tidyverse`](https://www.tidyverse.org/) : a collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structure.\n\n-   [`raster`](https://cran.r-project.org/web/packages/raster/) : reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.\n\n-   [`tmap`](https://cran.r-project.org/web/packages/tmap/): Packages used for creating static and interactive visualisations summary statistics and KDE layers.\n\n-   `lubridate`: splits the data into quarters by their years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, st, tidyverse, raster, tmap, ggplot2, spatstat, lubridate, sparr)\n```\n:::\n\n\n## **Importing Dataset into R environment**\n\n### **Datasets**\n\n1.  For the purpose of this assignment, **armed conflict data** of Myanmar between January 2021 - June 2024 from [Armed Conflict Location & Event Data (ACLED)](https://acleddata.com/). Our analysis concentrates on four primary event categories: Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.\n\n2.  We will also use geospatial data on the Myanmar National Border in ESRI Shapefile format. [(Myanmar National Boundary MIMU v9.4)](http://geonode.themimu.info/layers/geonode%3Ammr_polbnda_adm0_250k_mimu_1)\n\n### **Importing the Datasets**\n\n#### Myanmar Armed Conflict Dataset\n\nThe dataset, which we downloaded from ACLED, is in csv format. To use this data in an R-environment, we need to import it as an sf object. We can do this using the **`st_read()`** function of the **`sf`** package. This function reads the csv data and returns an **`sf`** object that can be used for further analysis.\n\nThe data has also been transformed such that the EPSG coordinates are accurate to Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- read_csv(\"data/2021-01-01-2024-06-30-Myanmar.csv\") %>%\n  st_as_sf(coords = c(\n    \"longitude\", \"latitude\"),\n    crs=4326) %>%\n  st_transform(crs = 32647) %>%\n  mutate(event_date = dmy(event_date))\n```\n:::\n\n\nThe `event_date` column is categorized by\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf <- acled_sf %>%\n  mutate(quarter = quarter(event_date))\n```\n:::\n\n\n#### Myanmar Administrative Boundary Data\n\nThe code chunk below uses [`st_read()`](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Myanmar shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_sf <- st_read(dsn = \"data\", \n                 layer = \"mmr_polbnda2_adm1_250k_mimu_1\") %>%\n  st_as_sf(coords =c(\n    \"longitude\", \"latitude\"),\n           crs = 4326) %>%\n  st_transform(crs = 32647)\n```\n:::\n\n\n### **Mapping geospatial data sets**\n\nIt is useful for us to plot a map to show spatial patters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\n```\n:::\n\n\nThe code below plots the armed conflict data in Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf %>%   tm_shape()+tm_dots()\n```\n:::\n\n\n## **Geospatial Data Wrangling**\n\n### **Separating data by the year and quarters**\n\nThe code chunk below separates the data provided into years and quarters for easier plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2021\nacled_2021.Q1_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '1')\n\nacled_2021.Q2_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '2')\n\nacled_2021.Q3_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '3')\n\nacled_2021.Q4_sf <- acled_sf %>%\n  filter(year == '2021') %>%\n  filter(quarter == '4')\n\n# 2022\nacled_2022.Q1_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '1')\n\nacled_2022.Q2_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '2')\n\nacled_2022.Q3_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '3')\n\nacled_2022.Q4_sf <- acled_sf %>%\n  filter(year == '2022') %>%\n  filter(quarter == '4')\n\n\n# 2023\nacled_2023.Q1_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '1')\n\nacled_2023.Q2_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '2')\n\nacled_2023.Q3_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '3')\n\nacled_2023.Q4_sf <- acled_sf %>%\n  filter(year == '2023') %>%\n  filter(quarter == '4')\n\n\n# 2024\nacled_2024.Q1_sf <- acled_sf %>%\n  filter(year == '2024') %>%\n  filter(quarter == '1')\n\nacled_2024.Q2_sf <- acled_sf %>%\n  filter(year == '2024') %>%\n  filter(quarter == '2')\n```\n:::\n\n\n### **Converting sf data frames to sp’s Spatial\\* class**\n\nThe code chunk below uses [*as_Spatial()*](https://r4gdsa.netlify.app/chap04.html?q=KDE%20layers) of **sf** package to convert the geospatial data from sf data frame to sp’s Spatial\\* class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled <- as_Spatial(acled_sf)\n\n# by quarters\nacled_2021.Q1 <- as_Spatial(acled_2021.Q1_sf)\nacled_2021.Q2 <- as_Spatial(acled_2021.Q2_sf)\nacled_2021.Q3 <- as_Spatial(acled_2021.Q3_sf)\nacled_2021.Q4 <- as_Spatial(acled_2021.Q4_sf)\n\nacled_2022.Q1 <- as_Spatial(acled_2022.Q1_sf)\nacled_2022.Q2 <- as_Spatial(acled_2022.Q2_sf)\nacled_2022.Q3 <- as_Spatial(acled_2022.Q3_sf)\nacled_2022.Q4 <- as_Spatial(acled_2022.Q4_sf)\n\nacled_2023.Q1 <- as_Spatial(acled_2023.Q1_sf)\nacled_2023.Q2 <- as_Spatial(acled_2023.Q2_sf)\nacled_2023.Q3 <- as_Spatial(acled_2023.Q3_sf)\nacled_2023.Q4 <- as_Spatial(acled_2023.Q4_sf)\n\nacled_2024.Q1 <- as_Spatial(acled_2024.Q1_sf)\nacled_2024.Q2 <- as_Spatial(acled_2024.Q2_sf)\n```\n:::\n\n\n### **Converting simple features to spatstat’s ppp (planar point pattern) object**\n\n**spatstat** requires the analytical data in ***ppp*** object form. Hence we will convert `sf` objects to `ppp` objects using [`as.ppp()`](https://rdrr.io/pkg/spatstat.geom/man/as.ppp.html) function by providing the point coordinates and the observation window.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacled_ppp <- as.ppp(st_coordinates(acled_sf), st_bbox(acled_sf))\n\n# by quarters\nacled_2021.Q1_ppp <- as.ppp(st_coordinates(acled_2021.Q1_sf), st_bbox(acled_2021.Q1_sf))\nacled_2021.Q2_ppp <- as.ppp(st_coordinates(acled_2021.Q2_sf), st_bbox(acled_2021.Q2_sf))\nacled_2021.Q3_ppp <- as.ppp(st_coordinates(acled_2021.Q3_sf), st_bbox(acled_2021.Q3_sf))\nacled_2021.Q4_ppp <- as.ppp(st_coordinates(acled_2021.Q4_sf), st_bbox(acled_2021.Q4_sf))\n\nacled_2022.Q1_ppp <- as.ppp(st_coordinates(acled_2022.Q1_sf), st_bbox(acled_2022.Q1_sf))\nacled_2022.Q2_ppp <- as.ppp(st_coordinates(acled_2022.Q2_sf), st_bbox(acled_2022.Q2_sf))\nacled_2022.Q3_ppp <- as.ppp(st_coordinates(acled_2022.Q3_sf), st_bbox(acled_2022.Q3_sf))\nacled_2022.Q4_ppp <- as.ppp(st_coordinates(acled_2022.Q4_sf), st_bbox(acled_2022.Q4_sf))\n\nacled_2023.Q1_ppp <- as.ppp(st_coordinates(acled_2023.Q1_sf), st_bbox(acled_2023.Q1_sf))\nacled_2023.Q2_ppp <- as.ppp(st_coordinates(acled_2023.Q2_sf), st_bbox(acled_2023.Q2_sf))\nacled_2023.Q3_ppp <- as.ppp(st_coordinates(acled_2023.Q3_sf), st_bbox(acled_2023.Q3_sf))\nacled_2023.Q4_ppp <- as.ppp(st_coordinates(acled_2023.Q4_sf), st_bbox(acled_2023.Q4_sf))\n\nacled_2024.Q1_ppp <- as.ppp(st_coordinates(acled_2024.Q1_sf), st_bbox(acled_2024.Q1_sf))\nacled_2024.Q2_ppp <- as.ppp(st_coordinates(acled_2024.Q2_sf), st_bbox(acled_2024.Q2_sf))\n\nplot(acled_2021.Q1_ppp)\n```\n:::\n\n\nHeres the summary statistics of the newly created ppp object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(acled_2021.Q1_ppp)\n```\n:::\n\n\n### **Handling duplicated points**\n\nIt is previously mentioned in `summary(acled_ppp)` that there are duplicated points in the patterns. We can double confirm the duplication in a ***ppp*** object by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(acled_2021.Q1_ppp))\n```\n:::\n\n\nSince the above code chunk returns TRUE, we will use `sum()` and `multiplicity()` functions to see how many locations have more than one point event.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(multiplicity(acled_2021.Q1_ppp) > 1)\n```\n:::\n\n\nWe can address this by using `rjitter()` which will add a small perturbation to the duplicate points so that they do not occupy the exact same spaces.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacled_ppp_jit <- rjitter(acled_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\n# by quarters\nacled_2021.Q1_ppp_jit <- rjitter(acled_2021.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q2_ppp_jit <- rjitter(acled_2021.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q3_ppp_jit <- rjitter(acled_2021.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2021.Q4_ppp_jit <- rjitter(acled_2021.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2022.Q1_ppp_jit <- rjitter(acled_2022.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q2_ppp_jit <- rjitter(acled_2022.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q3_ppp_jit <- rjitter(acled_2022.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2022.Q4_ppp_jit <- rjitter(acled_2022.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2023.Q1_ppp_jit <- rjitter(acled_2023.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q2_ppp_jit <- rjitter(acled_2023.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q3_ppp_jit <- rjitter(acled_2023.Q3_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2023.Q4_ppp_jit <- rjitter(acled_2023.Q4_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nacled_2024.Q1_ppp_jit <- rjitter(acled_2024.Q1_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\nacled_2024.Q2_ppp_jit <- rjitter(acled_2024.Q2_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n```\n:::\n\n\nWe will check if there is still any duplicate points in our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(acled_2021.Q1_ppp_jit))\n```\n:::\n\n\n### **Creating *owin* object**\n\nSince we have imported the Myanmar boundary, we will now convert the `myanmar_sf` object into an `owin` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_owin <- as.owin(myanmar_sf)\nplot(myanmar_owin)\n\nsummary(myanmar_owin)\n```\n:::\n\n\n### **Creating point events objects in owin Object**\n\nIn this last step of geospatial data wrangling, we will extract armed conflict events that are located within Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacledmyanmar_ppp = acled_ppp[myanmar_owin]\n\n# by quarters\nacledmyanmar_2021.Q1_ppp = acled_2021.Q1_ppp[myanmar_owin]\nacledmyanmar_2021.Q2_ppp = acled_2021.Q2_ppp[myanmar_owin]\nacledmyanmar_2021.Q3_ppp = acled_2021.Q3_ppp[myanmar_owin]\nacledmyanmar_2021.Q4_ppp = acled_2021.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2022.Q1_ppp = acled_2022.Q1_ppp[myanmar_owin]\nacledmyanmar_2022.Q2_ppp = acled_2022.Q2_ppp[myanmar_owin]\nacledmyanmar_2022.Q3_ppp = acled_2022.Q3_ppp[myanmar_owin]\nacledmyanmar_2022.Q4_ppp = acled_2022.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2023.Q1_ppp = acled_2023.Q1_ppp[myanmar_owin]\nacledmyanmar_2023.Q2_ppp = acled_2023.Q2_ppp[myanmar_owin]\nacledmyanmar_2023.Q3_ppp = acled_2023.Q3_ppp[myanmar_owin]\nacledmyanmar_2023.Q4_ppp = acled_2023.Q4_ppp[myanmar_owin]\n\nacledmyanmar_2024.Q1_ppp = acled_2024.Q1_ppp[myanmar_owin]\nacledmyanmar_2024.Q2_ppp = acled_2024.Q2_ppp[myanmar_owin]\n```\n:::\n\n\nThe output object combines both the point and polygon feature in one `ppp` object class as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(acledmyanmar_2021.Q1_ppp)\n\nplot(acledmyanmar_2021.Q1_ppp)\n```\n:::\n\n\n## **First-order Spatial Point Patterns Analysis**\n\nAfter data wrangling is complete, we will perform first-order spatial point pattern analysis using functions from the `spatstat` package.\n\n### **Quarterly KDE layers**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nacledmyanmar_ppp.km <- rescale(acledmyanmar_ppp, 1000, \"km\")\n\n# by quarters\nacledmyanmar_2021.Q1_ppp.km <- rescale(acledmyanmar_2021.Q1_ppp, 1000, \"km\")\nacledmyanmar_2021.Q2_ppp.km <- rescale(acledmyanmar_2021.Q2_ppp, 1000, \"km\")\nacledmyanmar_2021.Q3_ppp.km <- rescale(acledmyanmar_2021.Q3_ppp, 1000, \"km\")\nacledmyanmar_2021.Q4_ppp.km <- rescale(acledmyanmar_2021.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2022.Q1_ppp.km <- rescale(acledmyanmar_2022.Q1_ppp, 1000, \"km\")\nacledmyanmar_2022.Q2_ppp.km <- rescale(acledmyanmar_2022.Q2_ppp, 1000, \"km\")\nacledmyanmar_2022.Q3_ppp.km <- rescale(acledmyanmar_2022.Q3_ppp, 1000, \"km\")\nacledmyanmar_2022.Q4_ppp.km <- rescale(acledmyanmar_2022.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2023.Q1_ppp.km <- rescale(acledmyanmar_2023.Q1_ppp, 1000, \"km\")\nacledmyanmar_2023.Q2_ppp.km <- rescale(acledmyanmar_2023.Q2_ppp, 1000, \"km\")\nacledmyanmar_2023.Q3_ppp.km <- rescale(acledmyanmar_2023.Q3_ppp, 1000, \"km\")\nacledmyanmar_2023.Q4_ppp.km <- rescale(acledmyanmar_2023.Q4_ppp, 1000, \"km\")\n\nacledmyanmar_2024.Q1_ppp.km <- rescale(acledmyanmar_2024.Q1_ppp, 1000, \"km\")\nacledmyanmar_2024.Q2_ppp.km <- rescale(acledmyanmar_2024.Q2_ppp, 1000, \"km\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_acledmyanmar_2021.Q1.bw <- density(acledmyanmar_2021.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q2.bw <- density(acledmyanmar_2021.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q3.bw <- density(acledmyanmar_2021.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2021.Q4.bw <- density(acledmyanmar_2021.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2022.Q1.bw <- density(acledmyanmar_2022.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q2.bw <- density(acledmyanmar_2022.Q2_ppp.km, \n                                      sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q3.bw <- density(acledmyanmar_2022.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2022.Q4.bw <- density(acledmyanmar_2022.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2023.Q1.bw <- density(acledmyanmar_2023.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q2.bw <- density(acledmyanmar_2023.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q3.bw <- density(acledmyanmar_2023.Q3_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2023.Q4.bw <- density(acledmyanmar_2023.Q4_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n\nkde_acledmyanmar_2024.Q1.bw <- density(acledmyanmar_2024.Q1_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\nkde_acledmyanmar_2024.Q2.bw <- density(acledmyanmar_2024.Q2_ppp.km, \n                                       sigma=20, \n                                       edge=TRUE, \n                                       kernel=\"gaussian\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(kde_acledmyanmar_2021.Q1.bw)\nplot(kde_acledmyanmar_2021.Q2.bw)\nplot(kde_acledmyanmar_2021.Q3.bw)\nplot(kde_acledmyanmar_2021.Q4.bw)\n\nplot(kde_acledmyanmar_2022.Q1.bw)\nplot(kde_acledmyanmar_2022.Q2.bw)\nplot(kde_acledmyanmar_2022.Q3.bw)\nplot(kde_acledmyanmar_2022.Q4.bw)\n\nplot(kde_acledmyanmar_2023.Q1.bw)\nplot(kde_acledmyanmar_2023.Q2.bw)\nplot(kde_acledmyanmar_2023.Q3.bw)\nplot(kde_acledmyanmar_2023.Q4.bw)\n\nplot(kde_acledmyanmar_2024.Q1.bw)\nplot(kde_acledmyanmar_2024.Q2.bw)\n```\n:::\n\n\n# **Second-order Spatial Point Patterns Analysis**\n\n## **Data Wrangling for Second-order analysis**\n\n#### Extracting study areas\n\nThe code chunk below targets the areas with the highest amount of activity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_sf\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI <- myanmar_sf %>%\n  filter(ST == \"Sagaing\")\nKC <- myanmar_sf %>%\n  filter(ST == \"Kachin\")\nMW <- myanmar_sf %>%\n  filter(ST == \"Magway\")\nMDL <- myanmar_sf %>%\n  filter(ST == \"Mandalay\")\n```\n:::\n\n\n#### Combining event points and the study area\n\nBy using the code chunk below, we are able to extract events that is within specific regions to do our analysis later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_owin <- as.owin(SGI)\nKC_owin <- as.owin(KC)\nMW_owin <- as.owin(MW)\nMDL_owin <- as.owin(MDL)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_ppp = acled_ppp_jit[SGI_owin] \nKC_ppp = acled_ppp_jit[KC_owin] \nMW_ppp = acled_ppp_jit[MW_owin] \nMDL_ppp = acled_ppp_jit[MDL_owin]\n```\n:::\n\n\n`rescale()` is used to transform the unit of measurement from meters to kilometers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSGI_ppp.km = rescale(SGI_ppp, 1000, \"km\") \nKC_ppp.km = rescale(KC_ppp, 1000, \"km\") \nMW_ppp.km = rescale(MW_ppp, 1000, \"km\") \nMDL_ppp.km = rescale(MDL_ppp, 1000, \"km\")\n```\n:::\n\n\nThe code chunk below plots the four study areas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2)) \nplot(SGI_ppp.km, main=\"Sagaing\") \nplot(KC_ppp.km, main=\"Kachin\") \nplot(MW_ppp.km, main=\"Magway\") \nplot(MDL_ppp.km, main=\"Mandalay\")\n```\n:::\n\n\n## **Analysing Spatial Point Process Using G-Function**\n\n#### Kachin area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_KC = Gest(KC_ppp, correction = \"border\") \nplot(G_KC, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Kachin are randomly distributed.\n\n-   H1= The distribution of events in Kachin are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_KC.csr <- envelope(KC_ppp, Gest, nsim = 999)\n\nplot(G_KC.csr)\n```\n:::\n\n\n#### Magway area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW = Gest(MW_ppp, correction = \"border\") \n\nplot(G_MW, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Magway are randomly distributed.\n\n-   H1= The distribution of events in Magway are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW.csr <- envelope(MW_ppp, Gest, nsim = 999)\n\nplot(G_MW.csr)\n```\n:::\n\n\n#### Mandalay area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL = Gest(MDL_ppp, correction = \"border\") \n\nplot(G_MDL, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Mandalay are randomly distributed.\n\n-   H1= The distribution of events in Mandalay are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL.csr <- envelope(MDL_ppp, Gest, nsim = 999)\n\nplot(G_MDL.csr)\n```\n:::\n\n\n#### Sagaing area\n\nThe code chunk below is used to compute G-function using *Gest()* of **spatat** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI = Gest(SGI_ppp, correction = \"border\") \n\nplot(G_SGI, xlim=c(0,500))\n```\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\n-   Ho = The distribution of events in Sagaing are randomly distributed.\n\n-   H1= The distribution of events in Sagaing are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI.csr <- envelope(SGI_ppp, Gest, nsim = 999)\n\nplot(G_SGI.csr)\n```\n:::\n\n\n# **Computing Spatio-temporal KDE**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_sf_2021_mutated <- acled_sf %>% \n  filter(year == 2021) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2022_mutated <- acled_sf %>% \n  filter(year == 2022) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2023_mutated <- acled_sf %>% \n  filter(year == 2023) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_sf_2024_mutated <- acled_sf %>% \n  filter(year == 2024) %>%\n  mutate(Quarter_label = quarter(event_date))\n\nacled_quarter_2021 <- acled_sf_2021_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2022 <- acled_sf_2022_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2023 <- acled_sf_2023_mutated %>% \n  dplyr::select(Quarter_label)\n\nacled_quarter_2024 <- acled_sf_2024_mutated %>% \n  dplyr::select(Quarter_label)\n```\n:::\n\n\n### **Creating ppp object**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021_ppp <- as.ppp(acled_quarter_2021)\nacled_quarter_2022_ppp <- as.ppp(acled_quarter_2022)\nacled_quarter_2023_ppp <- as.ppp(acled_quarter_2023)\nacled_quarter_2024_ppp <- as.ppp(acled_quarter_2024)\n\nsummary(acled_quarter_2021_ppp)\nsummary(acled_quarter_2022_ppp)\nsummary(acled_quarter_2023_ppp)\nsummary(acled_quarter_2024_ppp)\n\nacled_quarter_2021_ppp <- rjitter(acled_quarter_2021_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2022_ppp <- rjitter(acled_quarter_2022_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2023_ppp <- rjitter(acled_quarter_2023_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\nacled_quarter_2024_ppp <- rjitter(acled_quarter_2024_ppp, \n                                 retry=TRUE, \n                                 nsim=1, \n                                 drop=TRUE)\n\nany(duplicated(acled_quarter_2021_ppp))\n```\n:::\n\n\n### **Including owin object**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacled_quarter_2021_owin <- acled_quarter_2021_ppp[myanmar_owin]\nacled_quarter_2022_owin <- acled_quarter_2022_ppp[myanmar_owin]\nacled_quarter_2023_owin <- acled_quarter_2023_ppp[myanmar_owin]\nacled_quarter_2024_owin <- acled_quarter_2024_ppp[myanmar_owin]\n\nplot(acled_quarter_2021_owin)\n```\n:::\n\n\n## **Computing spatio-temporal KDE by quarters**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacledmyanmar_2021_kde <- spattemp.density(acled_quarter_2021_owin)\nacledmyanmar_2022_kde <- spattemp.density(acled_quarter_2022_owin)\nacledmyanmar_2023_kde <- spattemp.density(acled_quarter_2023_owin)\nacledmyanmar_2024_kde <- spattemp.density(acled_quarter_2024_owin)\n```\n:::\n\n\n## **Computing spatio-temporal KDE by quarters**\n\n`spattemp.density()` of sparr package is used to compute the STKDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacledmyanmar_2021_kde <- spattemp.density(acled_quarter_2021_owin)\nacledmyanmar_2022_kde <- spattemp.density(acled_quarter_2022_owin)\nacledmyanmar_2023_kde <- spattemp.density(acled_quarter_2023_owin)\nacledmyanmar_2024_kde <- spattemp.density(acled_quarter_2024_owin)\n```\n:::\n\n\n### **Plotting the spatio-temporal KDE object**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquarters <- c(1,2,3,4)\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2021_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2021 Q\",i))\n}\n\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2022_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2022 Q\",i))\n}\n\npar(mfcol=c(1,4))\nfor(i in quarters){ \n  plot(acledmyanmar_2023_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2023 Q\",i))\n}\n\nquarters <- c(1,2)\npar(mfcol=c(1,2))\nfor(i in quarters){ \n  plot(acledmyanmar_2024_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at 2024 Q\",i))\n}\n```\n:::\n\n\n# **Displaying layers on openstreetmap**\n\n## **Displaying KDE layers**\n\n### **Displaying 2021**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_2021.Q1_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2021.Q2_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2021.Q3_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2021.Q3_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2021.Q4_sf)+\n  tm_dots()\n```\n:::\n\n\n### **Displaying 2022**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_2022.Q1_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2023.Q2_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2022.Q3_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2022.Q4_sf)+\n  tm_dots()\n```\n:::\n\n\n### **Displaying 2024**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_2024.Q1_sf)+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_2024.Q2_sf)+\n  tm_dots()\n```\n:::\n\n\n## **Displaying Spatio-Temporal KDE layers**\n\n### **Displaying 2021**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_sf_2021_mutated %>% \n        filter(Quarter_label == 1))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2021_mutated %>% \n        filter(Quarter_label == 2))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2021_mutated %>% \n        filter(Quarter_label == 3))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2021_mutated %>% \n        filter(Quarter_label == 4))+\n  tm_dots()\n```\n:::\n\n\n### **Displaying 2022**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_sf_2022_mutated %>% \n        filter(Quarter_label == 1))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2022_mutated %>% \n        filter(Quarter_label == 2))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2022_mutated %>% \n        filter(Quarter_label == 3))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2022_mutated %>% \n        filter(Quarter_label == 4))+\n  tm_dots()\n```\n:::\n\n\n### **Displaying 2023**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_sf_2023_mutated %>% \n        filter(Quarter_label == 1))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2023_mutated %>% \n        filter(Quarter_label == 2))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2023_mutated %>% \n        filter(Quarter_label == 3))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2023_mutated %>% \n        filter(Quarter_label == 4))+\n  tm_dots()\n```\n:::\n\n\n### **Displaying 2024**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('view')\ntm_shape(acled_sf_2024_mutated %>% \n        filter(Quarter_label == 1))+\n  tm_dots()\n\ntmap_mode('view')\ntm_shape(acled_sf_2024_mutated %>% \n        filter(Quarter_label == 2))+\n  tm_dots()\n```\n:::\n\n\n# **Insights and Differences between KDE and Spatio-temporal KDE maps**\n\nWhile it might seem intuitive to assume that KDE (Kernel Density Estimation) and STKDE (Spatio-Temporal Kernel Density Estimation) would yield similar results since they use the same data points, STKDE offers a distinct advantage by incorporating time as a variable. Both methods generally highlight similar patterns, showing conflicts concentrated in central Myanmar and along the outskirts. However, the intensity of these conflict clusters can differ between the two methods.\n\nFor instance, in our KDE analysis, adjustments to the sigma value were made to enhance visibility, which may account for variations in density intensity. In contrast, our STKDE analysis reveals lower intensity levels for certain periods, such as Q3 of 2023, suggesting less clustering of conflicts than initially anticipated. Conversely, in Q2 of 2024, KDE results indicate minimal conflict density across Myanmar, whereas STKDE highlights significant conflict clustering in central and peripheral areas, likely due to its ability to consider temporal factors.\n\nOverall, both KDE and STKDE consistently show conflict activity in central Myanmar and along the southern outskirts. Notably, in 2024, the data correlates with ongoing violence in Rakhine State, linked to the Arakan Army insurgency that began earlier this year.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}